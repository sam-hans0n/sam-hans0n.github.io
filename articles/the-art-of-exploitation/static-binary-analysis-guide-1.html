<!DOCTYPE html>

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script> <!-- REPLACE WITH DOWNLOADED VERSION -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="../../css/style.css"> <!-- Pretty sure relative paths are insecure, FUTURE SAM FIX!-->
  <title>Fuzzing JS Engines</title>
</head>

<body>
  <a href="../../index.html">
    <header id="header">
      <div id="header-name">Sam Hanson</div>
      <div id="header-title">Cybersecurity Research</div>
    </header>
  </a>

  <div id="banner"></div>

  <div id="article-body">
    <div id="article-inner-wrapper">
      <div id="article-title">Static Binary Analysis - from x86 assembly to C</div>
        <img id="malware-warning-png" class="main-article-pic" src="../../files/images/malware-warning.png"></img>
        <div class="section-header">
          What is static binary analysis?
          <p>
            Static binary analysis is the science of decoding the instructions and intentions of any given binary program
            without actually executing it.
          </p>
        </div>

        <div class="section-header">
          Why is static binary analysis important?
          <p>
            Fuzzing is a classification of software testing techniques that is based on generating permutations of input data
            and feeding them into a program to monitor its behaviour. This technique greatly increases the speed of dynamic binary
            analysis and is often used by researchers and bug hunters to find security flaws in software.
          </p>
        </div>

        <div class="section-header">
          Our chosen fuzzer
          <p>
            My research group chose a new fuzzing tool called <a href="https://github.com/SoftSec-KAIST/CodeAlchemist">CodeAlchemist</a> to use in our experiments.
            CodeAlchemist requires a set of "seed" JS files. These seeds will be broken down into "code bricks" and reassembled in various ways over
            thousands of interations. These newly created files will be executed by the engine and CodeAlchemist will monitor for any segmentation faults
            thrown by it.
            <br><br>

            CodeAlchemist is semantically aware, meaning the JS code CodeAlchemist produces is all valid and syntactically correct JS. This greatly increases
            our efficiency over other styles of fuzzing.<br><br>
            An example of two code bricks being assembled together to form valid JavaScript code:
            <div id="article-pic">
              <img src="../../files/images/codebrick.png"></img>
            </div>
          </p>
          <p>
            I won't go into details on the internals of CodeAlchemist in this article. More information can be found in the <a href="https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_05A-5_Han_paper.pdf">original
            CodeAlchemist authors paper.</a>
          </p>
        </div>


        <div class="section-header">

        </div>

    </div>
  </div>

</body>
</html>
